/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import { Block } from '../entities/block/block.entity';
import { Lease } from '../entities/lease/lease.entity';
import { Payment } from '../entities/payment/payment.entity';
import { mapToRecord } from '../utils/map-to-record.util';

import { ChangePoint, ChangePointDiff, PaymentsPayableService } from './payments-payable.service';

describe('PaymentsPayableService', () => {
  type TestBlock = Pick<Block, 'height' | 'blockReward' | 'fee' | 'previousFee'>;
  type TestLease = Pick<Lease, 'sender' | 'amount' | 'height' | 'cancelHeight'>;
  type TestPayment = Pick<Payment, 'address' | 'amount' | 'height'>;

  let serviceInstance: any;

  beforeAll(() => {
    // Instantiate with dummy dependencies; we only need the private method
    const service = new PaymentsPayableService(
      { percentageToDistribute: '90', nodeOwnerBeneficiaryAddress: 'beneficiary' } as any,
      {} as any,
      {} as any,
      {} as any
    );
    serviceInstance = service as any;
    serviceInstance.logger = {
      log: console.log,
      debug: console.debug,
      warn: console.warn,
      error: console.error,
      verbose: console.debug,
    };
  });

  describe('getSummaryData', () => {
    it('should return expected summary', async () => {
      const mockBlocks: TestBlock[] = [
        { height: 4655261, blockReward: '200000000', fee: '1600000', previousFee: '3100000' },
        { height: 4692667, blockReward: '200000000', fee: '17600000', previousFee: '4700000' },
        { height: 4694652, blockReward: '200000000', fee: '2500000', previousFee: '4500000' },
        { height: 4694773, blockReward: '200000000', fee: '12200000', previousFee: '11300000' },
        { height: 4700002, blockReward: '200000000', fee: '12500000', previousFee: '23500000' },
        { height: 4701750, blockReward: '200000000', fee: '9100000', previousFee: '7600000' },
        { height: 4705516, blockReward: '200000000', fee: '14600000', previousFee: '9600000' },
      ];
      const mockLeases: TestLease[] = [
        { sender: 'a', amount: '700000000000', height: 4690614 },
        { sender: 'a', amount: '700409100500', height: 4695613 },
        { sender: 'a', amount: '700411698357', height: 4699613 },
        { sender: 'a', amount: '701036918357', height: 4700614 },
      ];
      const mockPayments: TestPayment[] = [
        { address: 'a', amount: '625220000', height: 4699858 },
        { address: 'b', amount: '62522000', height: 4699858 },
      ];

      serviceInstance.blockService = {
        findAll: jest.fn().mockResolvedValue(mockBlocks),
      };
      serviceInstance.leaseService = {
        findAll: jest.fn().mockResolvedValue(mockLeases),
      };
      serviceInstance.paymentService = {
        findAll: jest.fn().mockResolvedValue(mockPayments),
      };

      const result = await serviceInstance.getSummaryData();
      console.log(result);
      expect(result).toEqual({
        indexerInfo: {
          blocks: { total: 7, minHeight: 4655261, maxHeight: 4705516 },
          leases: 4,
          payments: 2,
        },
        rewardsDistribution: {
          a: { amount: '1137708000', percent: '77.573' },
          // a little bit more 10%(as configured percentageToDistribute) + 12.427%(no leaser for 1st '4655261' block aka generated by self-power)
          beneficiary: { amount: '328912000', percent: '22.427' },
        },
        debt: { a: '512488000', beneficiary: '328912000' },
      });
    });
  });

  describe('calculateLeaseChangePointsDiff', () => {
    it('should return empty array for no leases', () => {
      const leases: TestLease[] = [];
      const result = serviceInstance.calculateLeaseChangePointsDiff(leases);
      expect(result).toEqual([]);
    });

    it('should skip zero diffs', () => {
      const leases: TestLease[] = [
        { sender: 's', amount: '1000', height: 5, cancelHeight: 10 },
        { sender: 's', amount: '1000', height: 10, cancelHeight: 20 },
        { sender: 's', amount: '500', height: 20 },
        { sender: 's', amount: '500', height: 20 },
      ];

      const result = serviceInstance.calculateLeaseChangePointsDiff(leases);

      expect(result).toEqual([{ height: 5, amount: 1000n, diff: 'increase' }]);
    });

    it('should become 0', () => {
      const leases: TestLease[] = [
        { sender: 's', amount: '1000', height: 5, cancelHeight: 10 },
        { sender: 's', amount: '500', height: 50, cancelHeight: 60 },
        { sender: 's', amount: '100', height: 50, cancelHeight: 60 },
      ];

      const result = serviceInstance.calculateLeaseChangePointsDiff(leases);

      expect(result).toEqual([
        { height: 5, amount: 1000n, diff: 'increase' },
        { height: 10, amount: 0n, diff: 'decrease' },
        { height: 50, amount: 600n, diff: 'increase' },
        { height: 60, amount: 0n, diff: 'decrease' },
      ]);
    });

    it('should compute increase and decrease diffs with correct accumulated amounts', () => {
      const leases: TestLease[] = [
        { sender: 's', amount: '1001', height: 5 },
        { sender: 's', amount: '1102', height: 15, cancelHeight: 25 },
        { sender: 's', amount: '1003', height: 20, cancelHeight: 30 },
        { sender: 's', amount: '1004', height: 25, cancelHeight: 45 },
        { sender: 's', amount: '1200', height: 30, cancelHeight: 45 },
        { sender: 's', amount: '2100', height: 40 },
      ];

      const result = serviceInstance.calculateLeaseChangePointsDiff(leases);

      expect(result).toEqual([
        { height: 5, amount: 1001n, diff: 'increase' },
        { height: 15, amount: 2103n, diff: 'increase' },
        { height: 20, amount: 3106n, diff: 'increase' },
        { height: 25, amount: 3008n, diff: 'decrease' },
        { height: 30, amount: 3205n, diff: 'increase' },
        { height: 40, amount: 5305n, diff: 'increase' },
        { height: 45, amount: 3101n, diff: 'decrease' },
      ]);
    });
  });

  describe('calculateGenerativePoints', () => {
    it('should return an empty array when input is empty', () => {
      expect(serviceInstance.calculateGenerativePoints([])).toEqual([]);
    });

    it('should compute a single-point window correctly', () => {
      const pts: ChangePointDiff[] = [{ height: 1000, amount: 500n, diff: 'increase' }];
      // maxHeight = 1000, windowEnd = min(1000+1000,1000)=1000
      expect(serviceInstance.calculateGenerativePoints(pts)).toEqual([{ height: 2000, amount: 500n }]);
    });

    it('should correctly process window', () => {
      const pts: ChangePointDiff[] = [
        { height: 1000, amount: 1000n, diff: 'increase' },
        { height: 2000, amount: 500n, diff: 'decrease' },
        { height: 3000, amount: 600n, diff: 'increase' },
      ];
      const result = serviceInstance.calculateGenerativePoints(pts);
      expect(result).toEqual([
        { height: 2000, amount: 500n },
        { height: 4000, amount: 600n },
      ]);
    });

    it('should become 0', () => {
      const pts: ChangePointDiff[] = [
        { height: 1000, amount: 500n, diff: 'increase' },
        { height: 2000, amount: 400n, diff: 'decrease' },
        { height: 4000, amount: 1000n, diff: 'increase' },
        { height: 6000, amount: 0n, diff: 'decrease' },
        { height: 6050, amount: 10n, diff: 'increase' },
        { height: 6150, amount: 0n, diff: 'decrease' },
      ];
      const result = serviceInstance.calculateGenerativePoints(pts);
      expect(result).toEqual([
        { height: 2000, amount: 400n },
        { height: 5000, amount: 1000n },
        { height: 6000, amount: 0n },
      ]);
    });

    it('should dedupe overlapping window-ends and pick the true min', () => {
      const pts: ChangePointDiff[] = [
        { height: 360000, amount: 400n, diff: 'increase' },
        { height: 360500, amount: 500n, diff: 'increase' },
        { height: 361001, amount: 300n, diff: 'decrease' },
        { height: 361050, amount: 450n, diff: 'increase' },
        { height: 361200, amount: 301n, diff: 'decrease' },
        { height: 361250, amount: 451n, diff: 'increase' },
        { height: 363050, amount: 1450n, diff: 'increase' },
        { height: 363200, amount: 1301n, diff: 'decrease' },
        { height: 363350, amount: 1451n, diff: 'increase' },
      ];

      const result = serviceInstance.calculateGenerativePoints(pts);
      expect(result).toEqual([
        { height: 361000, amount: 400n },
        { height: 361001, amount: 300n },
        { height: 362050, amount: 301n },
        { height: 362250, amount: 451n },
        { height: 363200, amount: 1301n },
        { height: 364350, amount: 1451n },
      ]);
    });

    it('should handle multiple generative changes within a series', () => {
      const pts: ChangePointDiff[] = [
        { height: 1000, amount: 1000n, diff: 'increase' },
        { height: 1500, amount: 900n, diff: 'decrease' },
        { height: 2500, amount: 950n, diff: 'increase' },
        { height: 2600, amount: 850n, diff: 'decrease' },
        { height: 3700, amount: 870n, diff: 'increase' },
      ];
      const result = serviceInstance.calculateGenerativePoints(pts);
      expect(result).toEqual([
        { height: 2000, amount: 900n }, // first change
        { height: 2600, amount: 850n }, // second change
        { height: 4700, amount: 870n }, // final shift
      ]);
    });

    it('should work correctly for dense overlapping windows', () => {
      const pts: ChangePointDiff[] = [
        { height: 1100, amount: 1000n, diff: 'increase' },
        { height: 1200, amount: 800n, diff: 'decrease' },
        { height: 1300, amount: 1200n, diff: 'increase' },
        { height: 2100, amount: 700n, diff: 'decrease' },
        { height: 2101, amount: 0n, diff: 'decrease' },
        { height: 2150, amount: 900n, diff: 'increase' },
        { height: 3100, amount: 600n, diff: 'decrease' },
      ];
      const result = serviceInstance.calculateGenerativePoints(pts);
      expect(result).toEqual([
        { height: 2100, amount: 700n }, // change at 1100 (window [100..1100])
        { height: 2101, amount: 0n }, // change at 1101 (window [100..1100])
        { height: 3150, amount: 600n }, // no new min, but falls within last change, remain?
      ]);
    });
  });

  describe('calculateGenerativeBalancePointsBySender', () => {
    it('should calculate generative points per sender', () => {
      const leases: Lease[] = [
        { sender: 'A', amount: '1000', height: 5000 },
        { sender: 'A', amount: '500', height: 1000, cancelHeight: 20000 },
        { sender: 'B', amount: '300', height: 800 },
      ] as any;

      const result = serviceInstance.calculateGenerativeBalancePointsBySender(leases);

      expect(mapToRecord(result)).toStrictEqual({
        A: [
          { height: 2000, amount: 500n },
          { height: 6000, amount: 1500n },
          { height: 20000, amount: 1000n },
        ],
        B: [{ height: 1800, amount: 300n }],
      });
    });
  });

  describe('getRewardsDistributionByAddress', () => {
    const calcBlockReward = (block: TestBlock): bigint => {
      const reward = BigInt(block.blockReward);
      const feePortion = (BigInt(block.fee) * 4n + BigInt(block.previousFee) * 6n) / 10n;
      return reward + feePortion;
    };

    it('should distribute rewards proportionally based on generative balance', () => {
      const blocks: TestBlock[] = [
        { height: 5, blockReward: '1000', fee: '102', previousFee: '200' }, // 1000+40+120 // 1160
        { height: 10, blockReward: '2000', fee: '200', previousFee: '400' }, // 2000+80+240 // 2320
      ];

      const genBalanceChangePointsBySender = new Map<string, ChangePoint[]>([
        ['sender1', [{ height: 0, amount: 1000n }]],
        ['sender2', [{ height: 0, amount: 2000n }]],
      ]);

      serviceInstance.nodeOwnerBeneficiaryAddress = 'owner';

      const result = serviceInstance.getRewardsDistributionByAddress(blocks, genBalanceChangePointsBySender);

      const block1Rewards = calcBlockReward(blocks[0]);
      const block2Rewards = calcBlockReward(blocks[1]);

      const sender1Expected = (block1Rewards * 9n * 1n) / 3n / 10n + (block2Rewards * 9n * 1n) / 3n / 10n;
      const sender2Expected = (block1Rewards * 9n * 2n) / 3n / 10n + (block2Rewards * 9n * 2n) / 3n / 10n;

      const total = blocks.reduce((acc, block) => acc + calcBlockReward(block), 0n);
      const ownerExpected = total - sender1Expected - sender2Expected;

      expect(result.get('sender1')?.amount).toBe(sender1Expected.toString());
      expect(result.get('sender2')?.amount).toBe(sender2Expected.toString());
      expect(result.get('owner')?.amount).toBe(ownerExpected.toString());
    });
  });

  describe('getLeasesMap', () => {
    it('should group leases by sender', () => {
      const leases: Lease[] = [
        { sender: 'A', amount: '100', height: 1 },
        { sender: 'B', amount: '200', height: 2 },
        { sender: 'A', amount: '300', height: 3 },
      ] as any;

      const result = serviceInstance.getLeasesMap(leases);

      expect(result.size).toBe(2);
      expect(result.get('A')).toHaveLength(2);
      expect(result.get('B')).toHaveLength(1);
    });
  });

  describe('getReward', () => {
    it('should calculate reward from block', () => {
      const block: Block = {
        blockReward: '1000',
        fee: '100',
        previousFee: '300',
      } as any;

      const result = serviceInstance.getReward(block);
      // 1000 + (100*4 + 300*6)/10 = 1000 + (400 + 1800)/10 = 1000 + 2200/10 = 1000 + 220 = 1220
      expect(result).toBe(1220n);
    });
  });

  describe('getDebtByAddress', () => {
    it('should compute debt correctly', () => {
      const distribution = new Map<string, { amount: string; percent: string }>();
      distribution.set('a', { amount: '1000', percent: '33.333' });
      distribution.set('b', { amount: '500', percent: '16.666' });
      distribution.set('c', { amount: '500', percent: '16.666' });
      distribution.set('d', { amount: '500', percent: '16.666' });
      distribution.set('e', { amount: '500', percent: '16.666' });

      const payments: any[] = [
        { address: 'a', amount: '700' },
        { address: 'b', amount: '100' },
        { address: 'c', amount: '500' },
        { address: 'd', amount: '1000' },
      ];

      const result = serviceInstance.getDebtByAddress(distribution, payments);

      expect(result.get('a')).toBe('300');
      expect(result.get('b')).toBe('400');
      expect(result.get('c')).toBe('0');
      expect(result.get('d')).toBe('-500');
      expect(result.get('e')).toBe('500');
    });
  });
});
